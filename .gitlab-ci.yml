variables:
  PACKAGE_PATH: /go/src/gitlab.com/iren.vasilevna/catalogue
######################
  CONTAINER_TEST_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  CONTAINER_RELEASE_IMAGE: $CI_REGISTRY_IMAGE:latest
  GROUP: weaveworksdemos
  COMMIT: $CI_BUILD_REF
  TAG: $CI_COMMIT_TAG 
######################
  REPO: catalogue
  MY_COOL_REGISTY: 10.128.0.9:5000
  GITLAB_OVERLAY: 1
  DOCKER_TLS_CERTDIR: "/certs"
#####################
  SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
  GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required by the analysis task

image: $MY_COOL_REGISTY/bios:dc-ssh

services:
  - name: docker:dind
    entrypoint: ["dockerd-entrypoint.sh"]
    command:  ["--insecure-registry=10.128.0.9:5000"]


    ############################ StageS
stages:
# make all needs microservices containers for integrated tests
#  - create_containers
#
  - release
  - build
  
  - test
  - create_containers
##  - sonarcloud-check
# make go environment, build test_container, make unit tests, integration mock tests, sends to artifactory
#  - release
# release for human rewiev
#  - deploy
# manual deploy to prod
 
# A hack to make Golang-in-Gitlab happy
# .anchors:
#   - &inject-gopath
#       mkdir -p $(dirname ${PACKAGE_PATH})
#       && ln -s ${CI_PROJECT_DIR} ${PACKAGE_PATH}
#       && cd ${PACKAGE_PATH}


    ############################ A hack to make Golang-in-Gitlab happy
.go_dind_gitlab_hack: &go_dind_gitlab_hack
  - 'export SHARED_PATH="$(dirname ${CI_PROJECT_DIR})/shared"' 
  - echo $SHARED_PATH
  - rm -rf ${SHARED_PATH}/*
  - ls -a ${SHARED_PATH}
  - mkdir -p ${SHARED_PATH}  && ln -s ${CI_PROJECT_DIR} ${SHARED_PATH}
  - 'export PACKAGE_PATH="$(dirname ${SHARED_PATH})/catalogue"' 
    ############################

    ############################ Stage
create_containers:
  stage: create_containers
#  tags:
#    - dev
  # only:
  #   - branches
 # except:
 #   - master
 #  dependencies:
 #   - dep

  script: 
    - echo $repo_user
    - echo $DOCKER_HOST

  after_script:
    - docker ps
    - docker images

    ############################ Stage
build:
  stage: build
  image: $MY_COOL_REGISTY/bios:dc-ssh
  before_script:
    - docker login -u$repo_user -p$repo_pass $MY_COOL_REGISTY

  script:
    - set -e
    - *go_dind_gitlab_hack
    
    #- go get -u github.com/FiloSottile/gvt
    # - go env GOPATH    
    #- gvt restore
    #- ./scripts/build.sh;



    #- cat ./deploy/script_gke_bootstrap_script.sh
    #- ls -la scripts/
    # - chmod +o scripts/
    #- chmod +x scripts/gke.sh
    #- ls -la scripts/
    # - ls -la scripts/
    #- scripts/gke.sh up





    # - docker build -t ${REPO}:${COMMIT} ./vendor
    # - docker build -t ${REPO}-db:${COMMIT} ./vendor

    # - docker tag ${REPO}:${COMMIT} ${MY_COOL_REGISTY}/${REPO}:${COMMIT}
    # - docker tag ${REPO}-db:${COMMIT} ${MY_COOL_REGISTY}/${REPO}-db:${COMMIT}

    # - docker push ${MY_COOL_REGISTY}/${REPO}:${COMMIT}
    # - docker push ${MY_COOL_REGISTY}/${REPO}-db:${COMMIT}

  after_script:
    - docker ps
    - docker images

    ############################ Stage
test:
  dependencies:
    - build
  stage: test
  image: $MY_COOL_REGISTY/bios:dc-ssh
  before_script:
    - docker login -u$repo_user -p$repo_pass $MY_COOL_REGISTY
    - docker login -u$ARTIFACTORY_USER -p$ARTIFACTORY_PASS $ARTIFACTORY_URL

  script:
    - set -e
    - apk add sudo
    - *go_dind_gitlab_hack

    # unit
    #- ./test/test1.sh unit.py
    # integr MySql, API
    #- ./test/test1.sh container.py --tag $TAG

  after_script:
    - echo "send to artifactory"
    - docker pull ${MY_COOL_REGISTY}/${REPO}:${COMMIT}
    - docker pull ${MY_COOL_REGISTY}/${REPO}-db:${COMMIT}

    - docker tag ${MY_COOL_REGISTY}/${REPO}:${COMMIT} $ARTIFACTORY_URL/${REPO}:${COMMIT}
    - docker tag ${MY_COOL_REGISTY}/${REPO}-db:${COMMIT} $ARTIFACTORY_URL/${REPO}-db:${COMMIT}

    - docker push $ARTIFACTORY_URL/${REPO}:${COMMIT}
    - docker push $ARTIFACTORY_URL/${REPO}-db:${COMMIT}

    - docker ps
    - docker images

    ############################ Stage
sonarcloud-check:
  image:
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - sonar-scanner -X
  only:
    - merge_requests
    - master
  #  - develop

    ############################ Stage
release:
  stage: release
  image: 'google/cloud-sdk:latest'
  before_script:
    - docker login -u$ARTIFACTORY_USER -p$ARTIFACTORY_PASS $ARTIFACTORY_URL
  script:
    - echo "$SERVICE_ACCOUNT_KEY" > key.json
    - gcloud auth activate-service-account --key-file=key.json
    - gcloud config set project $PROJECT
    - gcloud config set container/cluster $CLUSTER_NAME
    - gcloud config set compute/zone $REGION-$ZONE_EXTENSION

#    - gcloud container clusters create $CLUSTER_NAME --enable-autoupgrade --enable-autoscaling --min-nodes=2 --max-nodes=4 --num-nodes=4 --zone=$REGION-$ZONE_EXTENSION
    - gcloud container clusters get-credentials $CLUSTER_NAME --zone $REGION-$ZONE_EXTENSION

    - apt-get update
    - apt-get install gettext-base docker-ce docker-ce-cli containerd.io
    

    - cat deploy/stage1.yml | envsubst | kubectl apply -f -

   # - chmod +x ./deploy/prepare_yml.sh

    # - ls -al ./deploy
    # - ./deploy/prepare_yml.sh
    # - cat deploy.yml



    - echo "release to stage"

